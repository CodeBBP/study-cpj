<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1477998594413">{:repl-history {:ide [], :local [&quot;(defn my-tree-seq [branch?  root]\n  (let [walk (fn walk [node] (lazy-seq (cons node (when (branch? node)\n                                                    (println \&quot;node: \&quot; node)\n                                                    (map walk node)))))]\n    (walk root)\n    )\n  )&quot; &quot;(apply concat '((4) (4)))&quot; &quot;(defn my-tree-seq [branch?  root]\n  (let [walk (fn walk [node] (lazy-seq (when (branch? node)\n                                         (println \&quot;node: \&quot; node)\n                                         (map walk node))))]\n    (walk root)\n    )\n  )&quot; &quot;(defn my-tree-seq [branch?  root]\n  (let [walk (fn walk [node] (lazy-seq (cons node (when (branch? node)\n                                                    (println \&quot;node: \&quot; node)\n                                                    (mapcat walk node)))))]\n    (walk root)\n    )\n  )&quot; &quot;(cons '(3) 3)&quot; &quot;(cons '(3) '(3))&quot; &quot;(apply concat '((1 2 (3)) (1) (2) ((3) 3)))&quot; &quot;'((1 2 (3)) (4))&quot; &quot;(apply concat '((4) 4))&quot; &quot;(cons '(4) '(4))&quot; &quot;(apply concat '((1 2 (3)) (4)) '(1 2 (3) 1 2 (3) 3) '((4) 4))&quot; &quot;(apply concat '((1 2 (3)) (4))  '(1 2 (3) 1 2 (3) 3)  '((4) 4))&quot; &quot;(defn my-tree-seq [branch?  root]\n  (let [walk (fn walk [node] (lazy-seq (cons node (when (branch? node)\n                                                    (mapcat walk node)))))]\n    (walk root)\n    )\n  )&quot; &quot;(my-tree-seq seq?  '((1 2 (3)) (4)))&quot; &quot;#(loop [b 1\n        r (list)]\n  (if (&gt; b %)\n    r\n    (recur (inc b) (conj r ((fn yhsj [x y]\n                              (if (or (= x y) (= y 1))\n                                1\n                                (+ (yhsj (dec x) (dec y))\n                                   (yhsj (dec x) y)))) % b)))))\n&quot; &quot;#(loop [b 1\n        r (list)]\n  (if (&gt; b %)\n    r\n    (recur (inc b) (conj r ((fn yhsj [x y]\n                              (if (or (= x y) (= y 1))\n                                1\n                                (+ (yhsj (dec x) (dec y))\n                                   (yhsj (dec x) y)))) % b)))))&quot; &quot;(defn YH-triangle [x] (loop [b 1 r (list)]\n                        (if (&gt; b %) r\n                                    (recur (inc b) (conj r ((fn yh-triangle [x y]\n                                                              ( if (or (= x y) (= y 1)) 1 ;;如果x=y 或者 y=1\n                                                                                        ;;如果x!=y 或者 y!=1\n                                                                                        (+ (yh-triangle (dec x) (dec y))\n                                                                                           (yh-triangle (dec x) y)\n                                                                                           ))) % b)\n                                                         )))) 3)&quot; &quot;(defn YH-triangle [x] (loop [b 1 r (list)]\n                        (if (&gt; b %) r\n                                    (recur (inc b) (conj r ((fn yh-triangle [x y]\n                                                              ( if (or (= x y) (= y 1)) 1 ;;如果x=y 或者 y=1\n                                                                                        ;;如果x!=y 或者 y!=1\n                                                                                        (+ (yh-triangle (dec x) (dec y))\n                                                                                           (yh-triangle (dec x) y)\n                                                                                           ))) % b)\n                                                         )))) )&quot; &quot;(defn yht-core\n  [row line]\n  ( if (or (= x y) (= y 1)) 1 ;;如果x=y 或者 y=1\n                            (+ (yht-core (dec x) (dec y))\n                               (yht-core (dec x) y)\n                               )))&quot; &quot;(defn yht-core\n  [x y]\n  ( if (or (= x y) (= y 1)) 1 ;;如果x=y 或者 y=1\n                            (+ (yht-core (dec x) (dec y))\n                               (yht-core (dec x) y)\n                               )))&quot; &quot;(defn YH-triangle\n  [x]\n  (loop [b 1 r (list)] (if (&gt; b %) r  (recur (inc b) (conj r (yht-core % b))))))&quot; &quot;(defn YH-triangle\n  [row]\n  (loop [b 1 r (list)] (if (&gt; b row) r  (recur (inc b) (conj r (yht-core row b))))))&quot; &quot;(YH-triangle 3)&quot; &quot;(YH-triangle 4)&quot; &quot;(map YH-triangle 20)&quot; &quot;(map YH-triangle [1 2 3])&quot; &quot;(map YH-triangle (range 20))&quot; &quot;(defn fib\n  ([n] (take n (fib 1 1)))\n  ([a b] (lazy-seq (cons a (fib b (+ a b))))))&quot; &quot;(fib 5)&quot; &quot;(fib 10)&quot; &quot;(comp [])&quot; &quot;(comp 1)&quot; &quot;(defn test-comp (comp + -))&quot; &quot;(def test-comp (comp + -))&quot; &quot;(test-comp 1 2)&quot; &quot;(def test-comp (comp + ))&quot; &quot;(test-comp 1 2 4)&quot; &quot;(comp #(+ %1 %2) 1 2 3)&quot; &quot;(def comp-test (comp #(+ %1 %2)))&quot; &quot;(comp-test 1 2 3)&quot; &quot;(comp-test 1 2)&quot; &quot;(map print [1 2 3])&quot; &quot;(map #(\&quot;取出的值：\&quot;  %) [1 2 3])&quot; &quot;(map #(print \&quot;取出的值：\&quot;  %) [1 2 3])&quot; &quot;(map #(print \&quot;取出的值：\&quot;  % ) [1 2 3])&quot; &quot;(map #(print \&quot;取出的值：\&quot;  % \&quot; \&quot;) [1 2 3])&quot; &quot;(\n  fn [x y] (if (zero? y) x (recur y (mod x y))) [1 2]\n  )&quot; &quot;(defn test [x y] (if (zero? y) x (recur y (mod x y))))&quot; &quot;(defn test-my [x y] (if (zero? y) x (recur y (mod x y))))&quot; &quot;(test-my [1 2])&quot; &quot;(test-my 1 2)&quot; &quot;(defn test-my [x y] (if (zero? y) x (print y) (recur y (mod x y))))&quot; &quot;(defn test-my [x y] (if (zero? y) (print \&quot;end: \&quot; x)  (recur (- y 1) (- x y))))&quot; &quot;(test-my 10 10)&quot; &quot;(test-my 13 2)&quot; &quot;(defn test-my [x y] (if (zero? y) (print \&quot;end: \&quot; x)  (recur (- x 2) (- y 1))))&quot; &quot;(defn test-my [x y] ( (print \&quot;xxx: \&quot; x) if (zero? y) (recur (- x 2) (- y 1))))&quot; &quot;(defn test-my [x y] (if (zero? y) x (print \&quot;xxx: \&quot; x) (recur (- x 2) (- y 1))))&quot; &quot;(defn test-my [x y] (if (zero? y) x (recur (- x 2) (- y 1))))&quot; &quot;(defn test-my [x y] ((print \&quot;1111\&quot;)  if (zero? y) x (recur (- x 2) (- y 1))))&quot; &quot;(defn test-my [x y] (print \&quot;xxx:\&quot; x) (if (zero? y) x (recur (- x 2) (- y 1))))&quot; &quot;(defn test-my [x y] (print \&quot; xxx:\&quot; x) (if (zero? y) x (recur (- x 2) (- y 1))))&quot; &quot;(test-my 10 5)&quot; &quot;(defn fib [n]\n  (condp = n\n    0 1\n    1 1\n    (+ (fib (dec n)) (fib (- n 2)))))&quot; &quot;(time (fib 30))&quot; &quot;(time (fib 50)) &quot; &quot;(defn fib [n]\n  (condp = n\n    0 1\n    1 1\n    (+ (fib (dec n)) (fib (- n 2)))))\n(time (fib 40))   &quot; &quot;(def m-fib\n  (memoize (fn [n]\n             (condp = n\n               0 1\n               1 1\n               (+ (m-fib (dec n)) (m-fib (- n 2)))))))\n(time (m-fib 30))  &quot; &quot;(def m-fib\n  (memoize (fn [n]\n             (condp = n\n               0 1\n               1 1\n               (+ (m-fib (dec n)) (m-fib (- n 2)))))))&quot; &quot;(time (m-fib 50)) &quot; &quot;(time (m-fib 40))  &quot; &quot;(defn fun-test [x] (+ x 1))&quot; &quot;(defn fun-test [x] (print ) (+ x 1))&quot; &quot;(defn fun-test [x] (print \&quot;execute!\&quot;))&quot; &quot;(defn fun-test [x] (print \&quot;execute!\&quot;) (+ x 1))&quot; &quot;(def me-fun-test (memoize fun-test))&quot; &quot;(me-fun-test 12)&quot; &quot;(me-fun-test 13)&quot; &quot;(me-fun-test 14)&quot; &quot;(me-fun-test 15)&quot; &quot;(me-fun-test 16)&quot; &quot;(me-fun-test 17)&quot; &quot;(me-fun-test 18)&quot; &quot;(me-fun-test 19)&quot; &quot;(me-fun-test 20)&quot; &quot;(me-fun-test 11)&quot; &quot;((every-pred (constantly false)))\n&quot; &quot;((some-fn even? #(&lt; % 10)) 1 2 3)&quot; &quot;((some-fn even? #(&lt; % 2)) 1 2 3)&quot; &quot;(or true false)&quot; &quot;(and true false)&quot; &quot;(and false false)&quot; &quot;(or false false)&quot; &quot;((some-fn even? #(&gt; % 2)) 1 2 3)&quot; &quot;((some-fn even? #(&gt; % 2)) 1  3)&quot; &quot;((some-fn even? #(&gt; % 4)) 1  3)&quot; &quot;(map #(* % %) [1 2 3 4 5 6 7 8 9 10])&quot; &quot;(defn xxx [x y] (* x y))&quot; &quot;(map xxx [1 2 3 4 5 6 7 8 9])&quot; &quot;(defn foo [x]\n  (if (&lt; x 0)\n    (println \&quot;done\&quot;)\n    #(foo (do (println :x x) (dec x)))))&quot; &quot;(foo 10)&quot;], :remote []}}</component>
</project>