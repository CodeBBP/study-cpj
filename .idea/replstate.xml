<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1477560207649">{:repl-history {:ide [], :local [&quot;((when ([1 2 3])) \&quot;true\&quot; \&quot;false\&quot;)&quot; &quot;(max-key #(+ % 1) 1 2 3 4 5)&quot; &quot;(max-key 1 2 3 4 5)&quot; &quot;(max-key str 1 2 3 4 5)&quot; &quot;(key (apply max-key val {:a 3 :b 7 :c 9 :d 9}))&quot; &quot;(max-key #(+ % 1) 1 2 3  8 4 5)&quot; &quot;(seq [])&quot; &quot;(when-first [a []] :x)&quot; &quot;(when-first [a []] a)&quot; &quot;(min-key count \&quot;asd\&quot; \&quot;bsd\&quot; \&quot;dsd\&quot; \&quot;long word\&quot;)&quot; &quot;(zipmap [:a :b :c] (range 10))&quot; &quot;(reduce conj [-1 -2] (-&gt;&gt; (range 10) (map #(+ 2 %)) (filter odd?)))&quot; &quot;(reduce list [])&quot; &quot;(reduce #(+ % 1) [])&quot; &quot;(reduce #(+ % 1) [1])&quot; &quot;(reduce #(+ % 1) [2])&quot; &quot;(reduce #(+ % %2 1) 1 1 [2 3])&quot; &quot;(reduce #(+ % %2 1)  [2 3])&quot; &quot;(reduce #(+ % %2 1) 1 [2 3])&quot; &quot;(reduce #(+ % %2 1) 1 3 [2 3])&quot; &quot;(reduce #(+ % %2 1) [1 2] [2 3])&quot; &quot;(reduce #(apply + %) [1 2] [[2 3]])&quot; &quot;(reduce #(map + %) [[2 3]])&quot; &quot;(reduce #(map + %) [[2 3] [2 3]])&quot; &quot;(reduce #(map + % %) [[2 3] [2 3]])&quot; &quot;(reduce #(+ % %) [[2 3] [2 3]])&quot; &quot;(reduce #(+ (first %) (first %2)) [[2 3] [2 3]])&quot; &quot;(reduce str [])&quot; &quot;(reductions + 3 [1 2 3])&quot; &quot;(# '(1 1 2 3 2 4 5 5))&quot; &quot;(into # '(1 1 2 3 2 4 5 5))&quot; &quot;(into #  '(1 1 2 3 2 4 5 5))&quot; &quot;(into #{} '(1 1 2 3 2 4 5 5))&quot; &quot;( #{} '(1 1 2 3 2 4 5 5))&quot; &quot;(set nil)&quot; &quot;(into-array [1 2 3])&quot; &quot;(into-array Object [1 2 3 \&quot;4\&quot;])&quot; &quot;(into-array Object [1 2 3 \&quot;4\&quot; \&quot;a\&quot;])&quot; &quot;(def arrayy (into-array Object [1 2 3 \&quot;4\&quot; \&quot;a\&quot;]))&quot; &quot;arrayy 1&quot; &quot;arrayy [1]&quot; &quot;(arrayy 1)&quot; &quot;(get arrayy 1)&quot; &quot;(last arrayy)&quot; &quot;(into-array [\&quot;a\&quot; \&quot;b\&quot; \&quot;1\&quot; 2])&quot; &quot;(into-array [\&quot;a\&quot; \&quot;b\&quot; \&quot;1\&quot;])&quot; &quot;(into-array Byte/TYPE (range 4)) &quot; &quot;(into-array Byte/TYPE (range 4))&quot; &quot;(map + [1 2 3] [4 5 6])&quot; &quot;(map + [1 2 3] [4 5 6 7])&quot; &quot;(map + [1 2 3 5]  [4 5 6])&quot; &quot;(max 1 2 3)&quot; &quot;(max [1 2 3] [4 5 6])&quot; &quot;(doc max)&quot; &quot;(max [1 2 3])&quot; &quot;(map + [1 2 3])&quot; &quot;(map max [1 2 3])&quot; &quot;(mao #(apply max %) [1 2 3])&quot; &quot;(map #(apply max %) [1 2 3])&quot; &quot;(map #(+ 3 %) [1 2 3])&quot; &quot;(when (even? %) (print % \&quot; is ok!\&quot;) false)&quot; &quot;(when (even? 2) (print % \&quot; is ok!\&quot;) false)&quot; &quot;(let [x 3] x)&quot; &quot;(let [x 3] (when (even? x) (print x \&quot; is ok!\&quot;) false))&quot; &quot;(let [x 3] (when (even? x) (print x \&quot; is ok!\&quot;) (+ 1 x)))&quot; &quot;(let [x 3] (+ x 1))&quot; &quot;(when (even? 2) true)&quot; &quot;(when (even? 2) true false)&quot; &quot;(let [x 3] (when (even? x) (- 1 x) (+ 1 x)))&quot; &quot;(let [x 3] (when (even? x) true false))&quot; &quot;(some #(when (even? %) %) '(1 2 3 4)) &quot; &quot;(some #(when (even? %) (+ 1 %)) '(1 2 3 4)) &quot; &quot;(some #(when (even? %) (+ 1 \n                          %)) '(1 2 3 4)) &quot; &quot;(some {3 nill} [nil 3 2])&quot; &quot;(some {3 nil} [nil 3 2])&quot; &quot;(some {3 nil 4 \&quot;da\&quot;} [nil 3 2])&quot; &quot;(some {2 \&quot;答复\&quot;  3 nil 4 \&quot;da\&quot;} [nil 3 2])&quot; &quot;(some {2 \&quot;two\&quot; 3 nil} [nil 3 2])&quot; &quot;(some {4 \&quot;four\&quot; 3 nil} [nil 3 2])&quot; &quot;(some {4 \&quot;four\&quot; 3 nil} [nil 3 4])&quot; &quot;(first (filter even? [1 2 3 4])) &quot; &quot;(some #(if (even? %) %) [1 2 3 4])&quot; &quot;(some #(when (even? %) %) [1 3 5 7 8 2])&quot; &quot;(some #(and (even? %) %) '(1 2 3 4)) &quot; &quot;(def my-seq [\&quot;a\&quot; \&quot;b\&quot; \&quot;c\&quot; \&quot;d\&quot;])&quot; &quot;(nth my-seq 1)  &quot; &quot;(nth [] 0)&quot; &quot;(use 'study_cpj)&quot; &quot;(ne 1 2 3)&quot; &quot;(ne 1 2)&quot; &quot;(use 'study_cpj.sheet)&quot; &quot;(list ne #(sumlt 10 %1 %2))&quot; &quot;(some #(% 3 7) (list ne #(sumlt 10 %1 %2)))&quot; &quot;(ne 3 7)&quot; &quot;(sumlt 10 3 7)&quot; &quot;(doseq [x [-1 0 1]\n        y [1  2 3]]\n  (prn (* x y)))&quot; &quot;(doseq [x [-1 0 1]\n        y [1  2 3]]\n  (print (* x y)))&quot; &quot;(doseq [x [-1 0 1]\n        y [1  2 3]]\n  (print \&quot; \&quot; (* x y)))&quot; &quot;(doseq [[x y] (map list [1 2 3] [1 2 3])]\n  (print (* x y)))&quot; &quot;(def digits (seq [1 2 3]))\n(for [x1 digits x2 digits] (* x1 x2))&quot; &quot;(def digits (seq [1 2 3]))&quot;], :remote []}}</component>
</project>